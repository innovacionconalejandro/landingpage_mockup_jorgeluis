<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jorge Luis Gonz치lez - Renderizado en Canvas</title>
    <!-- Se cargan las fuentes para que el canvas pueda intentar usarlas -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #f8f8f8;
            overflow-x: hidden; /* Evita el scroll horizontal */
        }
        canvas {
            display: block; /* Elimina el espacio extra debajo del canvas */
        }
    </style>
</head>
<body>

    <canvas id="websiteCanvas"></canvas>

    <script>
        // --- CONFIGURACI칍N INICIAL ---
        const canvas = document.getElementById('websiteCanvas');
        const ctx = canvas.getContext('2d');

        // Paleta de colores y fuentes del dise침o original
        const COLORS = {
            background: '#f8f8f8',
            textDark: '#333',
            textMedium: '#555',
            textLight: '#f8f8f8',
            headerBg: '#ffffff',
            heroBg: '#e0f2f7',
            primaryBlue: '#007bff',
            primaryOrange: '#ff9900',
            darkOrange: '#e68a00',
            footerBg: '#333',
            cardShadow: 'rgba(0,0,0,0.08)',
            sectionGray: '#f0f0f0',
            inputBorder: '#ddd'
        };

        const FONTS = {
            body: "'Poppins', sans-serif",
            heading: "'Montserrat', sans-serif"
        };
        
        // Contenido de texto extra칤do del HTML
        const CONTENT = {
            tagline: "Xperience, Xpansion, Growth",
            navLinks: ["Inicio", "Experiencia 4D", "Crecimiento", "Contacto"],
            heroTitle: "Jorge Luis Gonz치lez",
            heroSubtitle: "Estrategia y Crecimiento para transformar su negocio. Potenciamos resultados tangibles a trav칠s de una visi칩n 4D de la experiencia.",
            heroButton: "Conecta con Jorge",
            section1Title: "La Experiencia es un Fen칩meno 4D",
            section1Text: "En 2XG, entendemos que el 칠xito empresarial se forja en la gesti칩n estrat칠gica de m칰ltiples dimensiones. Cada una de ellas es crucial para un crecimiento sostenido y una ventaja competitiva.",
            cards: [
                { icon: "游늳", title: "1. Dimensi칩n Financiera", text: "Todo negocio es un negocio financiero. Alineamos estrategias y operaciones a objetivos financieros claros para maximizar la rentabilidad y el valor." },
                { icon: "丘뙖잺", title: "2. Dimensi칩n de Operaciones", text: "Una estrategia brillante no funciona sin una ejecuci칩n impecable. Optimizamos procesos y sistemas para una eficiencia operativa sin precedentes." },
                { icon: "游논", title: "3. Dimensi칩n Humana", text: "La cultura, las pol칤ticas y la gesti칩n de la remuneraci칩n son el motor de su empresa. Fomentamos un entorno que potencia el talento y la productividad." },
                { icon: "游꿢", title: "4. Dimensi칩n de Cara al Cliente", text: "Cada interacci칩n es una oportunidad. Desde la prospecci칩n hasta la retenci칩n, transformamos cada \"touch point\" en una ventaja competitiva." }
            ],
            section2Title: "Crecimiento Estrat칠gico y Expansi칩n",
            section2Text1: "La suma estrat칠gicamente gestionada de estas 4 dimensiones no solo produce un crecimiento, sino que detona una expansi칩n integral.",
            section2Text2: "Cuando el crecimiento supera los l칤mites actuales, es el momento de buscar nuevas oportunidades de mercado, ampliar el portafolio de productos y servicios, explorar nuevos territorios y diversificar los negocios del grupo. En 2XG, te guiamos en este camino de evoluci칩n constante.",
            contactTitle: "Conecta con Jorge Luis Gonz치lez",
            contactText1: "쯃isto para llevar tu estrategia y crecimiento al siguiente nivel? Cont치ctanos para una conversaci칩n personalizada sobre c칩mo podemos transformar tu negocio.",
            contactText2: "Tambi칠n puedes contactar directamente a trav칠s de:",
            contactInfo: "info@2xg.com | +XX XXX XXX XXXX",
            footerText1: "춸 2023 Jorge Luis Gonz치lez - 2XG. Todos los derechos reservados.",
            footerText2: "Potenciando Xperience, Xpansion, Growth.",
        };


        // --- FUNCIONES DE AYUDA (HELPERS) ---

        // Dibuja un rect치ngulo con bordes redondeados
        function drawRoundRect(x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();
        }

        // Dibuja texto con ajuste de l칤nea autom치tico
        function drawWrappedText(text, x, y, maxWidth, lineHeight, font, color, align = 'left') {
            ctx.font = font;
            ctx.fillStyle = color;
            ctx.textAlign = align;

            const words = text.split(' ');
            let line = '';
            let currentY = y;

            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    let lineX = x;
                    if (align === 'center') lineX = x + maxWidth / 2;
                    if (align === 'right') lineX = x + maxWidth;
                    ctx.fillText(line, lineX, currentY);
                    line = words[n] + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
             let lineX = x;
            if (align === 'center') lineX = x + maxWidth / 2;
            if (align === 'right') lineX = x + maxWidth;
            ctx.fillText(line, lineX, currentY);
            return currentY + lineHeight; // Devuelve la posici칩n Y final para el siguiente elemento
        }

        // --- FUNCIONES DE DIBUJO POR SECCI칍N ---

        function drawHeader(width) {
            const height = 100;
            const padding = width > 768 ? 50 : 20;

            // Fondo del header
            ctx.fillStyle = COLORS.headerBg;
            ctx.shadowColor = 'rgba(0,0,0,0.05)';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetY = 2;
            ctx.fillRect(0, 0, width, height);
            ctx.shadowColor = 'transparent'; // Resetear sombra

            // Logo placeholder
            ctx.fillStyle = COLORS.primaryBlue;
            ctx.font = `bold 30px ${FONTS.heading}`;
            ctx.textAlign = 'left';
            ctx.fillText("2XG", padding, 50);

            // Tagline
            ctx.fillStyle = '#666';
            ctx.font = `300 12px ${FONTS.heading}`;
            ctx.fillText(CONTENT.tagline, padding, 70);

            // Navegaci칩n
            if (width > 768) {
                ctx.fillStyle = COLORS.textMedium;
                ctx.font = `500 16px ${FONTS.body}`;
                ctx.textAlign = 'right';
                let currentX = width - padding;
                CONTENT.navLinks.slice().reverse().forEach(link => {
                    ctx.fillText(link, currentX, height / 2 + 8);
                    currentX -= ctx.measureText(link).width + 30;
                });
            } else {
                // Icono de men칰 hamburguesa para m칩viles
                 ctx.fillStyle = COLORS.textDark;
                 for(let i=0; i<3; i++) {
                     ctx.fillRect(width - padding - 30, height/2 - 10 + (i*8), 30, 3);
                 }
            }
            return height;
        }

        function drawHero(startY, width) {
            const height = 350;
            const padding = 20;
            
            // Fondo
            ctx.fillStyle = COLORS.heroBg;
            ctx.fillRect(0, startY, width, height);
            
            const contentWidth = Math.min(width - padding * 2, 800);
            const contentX = (width - contentWidth) / 2;
            let currentY = startY + 80;

            // T칤tulo principal
            currentY = drawWrappedText(CONTENT.heroTitle, contentX, currentY, contentWidth, 50, `bold 3em ${FONTS.heading}`, COLORS.primaryBlue, 'center') - 20;

            // Subt칤tulo
            currentY = drawWrappedText(CONTENT.heroSubtitle, contentX, currentY, contentWidth, 28, `1.2em ${FONTS.body}`, COLORS.textDark, 'center');

            // Bot칩n
            const btnWidth = 200;
            const btnHeight = 50;
            const btnX = (width - btnWidth) / 2;
            const btnY = currentY + 10;
            ctx.fillStyle = COLORS.primaryOrange;
            drawRoundRect(btnX, btnY, btnWidth, btnHeight, 5);

            ctx.fillStyle = COLORS.textLight;
            ctx.font = `600 1em ${FONTS.body}`;
            ctx.textAlign = 'center';
            ctx.fillText(CONTENT.heroButton, width / 2, btnY + btnHeight / 2 + 6);
            
            return startY + height;
        }

        function draw4DSection(startY, width) {
            const paddingTop = 80;
            const paddingX = width > 768 ? 50 : 20;
            const contentWidth = width - paddingX * 2;
            
            let currentY = startY + paddingTop;

            // T칤tulo de la secci칩n
            currentY = drawWrappedText(CONTENT.section1Title, paddingX, currentY, contentWidth, 40, `600 2.2em ${FONTS.heading}`, COLORS.textDark, 'center') + 10;

            // P치rrafo introductorio
            const introWidth = Math.min(contentWidth, 800);
            currentY = drawWrappedText(CONTENT.section1Text, (width - introWidth)/2, currentY, introWidth, 25, `1em ${FONTS.body}`, COLORS.textMedium, 'center') + 30;

            // Grid de cards
            const isMobile = width < 768;
            const gap = 30;
            const cols = isMobile ? 1 : 4;
            const cardWidth = (contentWidth - (gap * (cols - 1))) / cols;
            
            CONTENT.cards.forEach((card, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                const cardX = paddingX + col * (cardWidth + gap);
                const cardY = currentY + row * (400 + gap); // Altura fija para simplicidad

                // Dibujar la card
                ctx.fillStyle = '#fff';
                ctx.shadowColor = COLORS.cardShadow;
                ctx.shadowBlur = 15;
                ctx.shadowOffsetY = 4;
                drawRoundRect(cardX, cardY, cardWidth, 380, 8);
                ctx.shadowColor = 'transparent';

                let cardContentY = cardY + 40;
                
                // Icono
                ctx.font = '3em sans-serif'; // Emojis usan la fuente del sistema
                ctx.textAlign = 'center';
                ctx.fillText(card.icon, cardX + cardWidth/2, cardContentY + 20);
                cardContentY += 80;

                // T칤tulo de la card
                cardContentY = drawWrappedText(card.title, cardX + 20, cardContentY, cardWidth - 40, 30, `600 1.5em ${FONTS.heading}`, COLORS.primaryBlue, 'center');

                // Texto de la card
                drawWrappedText(card.text, cardX + 20, cardContentY, cardWidth - 40, 24, `1em ${FONTS.body}`, COLORS.textMedium, 'center');
            });

            const gridRows = Math.ceil(CONTENT.cards.length / cols);
            const totalGridHeight = gridRows * 380 + (gridRows - 1) * gap;
            
            return currentY + totalGridHeight + 80; // Espacio al final
        }

        function drawGrowthSection(startY, width) {
            const height = 300;
             // Fondo
            ctx.fillStyle = COLORS.sectionGray;
            ctx.fillRect(0, startY, width, height);

            const paddingX = width > 768 ? 50 : 20;
            const contentWidth = Math.min(width - paddingX * 2, 800);
            let currentY = startY + 60;

            // T칤tulo
            currentY = drawWrappedText(CONTENT.section2Title, (width-contentWidth)/2, currentY, contentWidth, 40, `600 2.2em ${FONTS.heading}`, COLORS.textDark, 'center') + 10;
            // P치rrafos
            currentY = drawWrappedText(CONTENT.section2Text1, (width-contentWidth)/2, currentY, contentWidth, 27, `1em ${FONTS.body}`, COLORS.textMedium, 'center');
            drawWrappedText(CONTENT.section2Text2, (width-contentWidth)/2, currentY, contentWidth, 27, `1em ${FONTS.body}`, COLORS.textMedium, 'center');

            return startY + height + 60;
        }

        function drawContactSection(startY, width) {
            const paddingTop = 80;
            const paddingX = width > 768 ? 50 : 20;
            const formWidth = Math.min(width - paddingX * 2, 500);
            const formX = (width - formWidth) / 2;
            
            let currentY = startY + paddingTop;

            // T칤tulo y texto
            const textWidth = Math.min(width - paddingX * 2, 800);
            currentY = drawWrappedText(CONTENT.contactTitle, (width-textWidth)/2, currentY, textWidth, 40, `600 2.2em ${FONTS.heading}`, COLORS.textDark, 'center') + 10;
            currentY = drawWrappedText(CONTENT.contactText1, (width-textWidth)/2, currentY, textWidth, 27, `1em ${FONTS.body}`, COLORS.textMedium, 'center') + 40;

            // Formulario (visual)
            const inputHeight = 50;
            const inputMargin = 20;
            
            // Campo Nombre
            ctx.strokeStyle = COLORS.inputBorder;
            ctx.lineWidth = 1;
            ctx.strokeRect(formX, currentY, formWidth, inputHeight);
            drawWrappedText("Tu Nombre", formX + 15, currentY + 32, formWidth - 30, 20, `1em ${FONTS.body}`, '#aaa');
            currentY += inputHeight + inputMargin;

            // Campo Email
            ctx.strokeRect(formX, currentY, formWidth, inputHeight);
            drawWrappedText("Tu Correo Electr칩nico", formX + 15, currentY + 32, formWidth - 30, 20, `1em ${FONTS.body}`, '#aaa');
            currentY += inputHeight + inputMargin;

            // Campo Mensaje
            const textAreaHeight = 120;
            ctx.strokeRect(formX, currentY, formWidth, textAreaHeight);
            drawWrappedText("Tu Mensaje", formX + 15, currentY + 32, formWidth - 30, 20, `1em ${FONTS.body}`, '#aaa');
            currentY += textAreaHeight + inputMargin;
            
            // Bot칩n Enviar
            ctx.fillStyle = COLORS.primaryOrange;
            ctx.fillRect(formX, currentY, formWidth, inputHeight);
            drawWrappedText("Enviar Mensaje", formX, currentY + 32, formWidth, 20, `600 1em ${FONTS.body}`, COLORS.textLight, 'center');
            currentY += inputHeight + 40;

            // Info de contacto final
            currentY = drawWrappedText(CONTENT.contactText2, (width-textWidth)/2, currentY, textWidth, 20, `0.9em ${FONTS.body}`, COLORS.textMedium, 'center');
            currentY = drawWrappedText(CONTENT.contactInfo, (width-textWidth)/2, currentY, textWidth, 20, `600 1.1em ${FONTS.body}`, COLORS.textDark, 'center');
            
            return currentY + 80;
        }

        function drawFooter(startY, width) {
            const height = 120;
            ctx.fillStyle = COLORS.footerBg;
            ctx.fillRect(0, startY, width, height);

            let currentY = startY + 40;
            currentY = drawWrappedText(CONTENT.footerText1, 0, currentY, width, 20, `0.9em ${FONTS.heading}`, COLORS.textLight, 'center');
            drawWrappedText(CONTENT.footerText2, 0, currentY, width, 20, `0.9em ${FONTS.heading}`, COLORS.textLight, 'center');

            return startY + height;
        }


        // --- FUNCI칍N PRINCIPAL DE DIBUJADO ---
        function drawWebsite() {
            // Limpiar el canvas
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Dibujar cada secci칩n secuencialmente, pasando la coordenada Y final de la anterior
            let currentY = 0;
            currentY = drawHeader(canvas.width);
            currentY = drawHero(currentY, canvas.width);
            currentY = draw4DSection(currentY, canvas.width);
            currentY = drawGrowthSection(currentY, canvas.width);
            currentY = drawContactSection(currentY, canvas.width);
            currentY = drawFooter(currentY, canvas.width);
            
            // Ajustar la altura total del canvas para que todo el contenido sea visible
            canvas.height = currentY;
            
            // Volver a dibujar todo con la altura correcta
            ctx.fillStyle = COLORS.background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            currentY = 0;
            currentY = drawHeader(canvas.width);
            currentY = drawHero(currentY, canvas.width);
            currentY = draw4DSection(currentY, canvas.width);
            currentY = drawGrowthSection(currentY, canvas.width);
            currentY = drawContactSection(currentY, canvas.width);
            currentY = drawFooter(currentY, canvas.width);
        }

        // --- MANEJO DEL TAMA칌O Y REDIBUJADO ---
        function resizeAndDraw() {
            // Ajustar el ancho del canvas al de la ventana
            canvas.width = window.innerWidth;
            // La altura se calcular치 din치micamente
            drawWebsite();
        }

        // Cargar las fuentes y luego dibujar
        // Usamos un peque침o retraso para dar tiempo a que las fuentes se carguen. 
        // Una soluci칩n m치s robusta usar칤a la FontFaceSet API.
        window.onload = () => {
             setTimeout(resizeAndDraw, 200);
        };
        window.addEventListener('resize', resizeAndDraw);

    </script>
</body>
</html>
